/* FILE: kl_anisotropy.h            -*-Mode: c++-*-
 *
 * Uniaxial Anisotropy, derived from Oxs_Energy class.
 * File based on origianl OOMMF code: uniaxialanisotropy.h
 * Added support for variable |M(r,t)| by Kristof Lebecki, nick KL(m), 
 * 2010, 2011, Universität Konstanz.
 *
 * Parameter "integration" (intergation method) allows for 
 * - LLB-style computation, where |M| can vary in space and time ("LLB"),
 * - "old style", standard computations (everything else, default).
 * In case of LLB computations you use susceptibilities instead of
 * anisotropy constants - see Garanin, PRB 55, 3050 (1997). 
 * In principle it should be possible to define different 
 * susceptibilities for different axes, that is however not implemented,
 * yet. ;)
 *
 */

#ifndef _KLM_ANISOTROPY
#define _KLM_ANISOTROPY

#include "nb.h"
#include "threevector.h"
#include "util.h"
#include "chunkenergy.h"
#include "energy.h"
#include "key.h"
#include "simstate.h"
#include "mesh.h"
#include "meshvalue.h"
#include "oxsthread.h"
#include "scalarfield.h"
#include "vectorfield.h"

/* End includes */

class Klm_Anisotropy:public Oxs_ChunkEnergy {
private:
  Oxs_OwnedPointer<Oxs_ScalarField> K1_init;
  Oxs_OwnedPointer<Oxs_VectorField> axis_init;
  mutable Oxs_ThreadControl thread_control;
  mutable OC_UINT4m mesh_id;
  mutable Oxs_MeshValue<OC_REAL8m> K1;
  mutable Oxs_MeshValue<ThreeVector> axis;
  /// K1 and axis are cached values filled by corresponding
  /// *_init members when a change in mesh is detected.

  // It is not uncommon for the anisotropy to be specified by uniform
  // fields.  In this case, memory traffic can be significantly
  // reduced, which may be helpful in parallelized code.  The
  // variables uniform_K1/axis_value are valid if the corresponding
  // boolean is true.
  OC_BOOL K1_is_uniform;
  OC_BOOL axis_is_uniform;
  OC_REAL8m uniform_K1_value;
  OC_REAL8m uniform_chi_x_value; // KL(m)
  OC_REAL8m uniform_chi_y_value; // KL(m)
  OC_REAL8m uniform_chi_z_value; // KL(m)
  ThreeVector uniform_axis_value;

  // KL(m)
  enum IntegrationMethod {
    UNKNOWN_INTEG, RECT_INTEG, QUAD_INTEG, LLB_INTEG
  } integration_method;
  /// Integration formulation to use.  "unknown" is invalid; it
  /// is defined for error detection.

  // RectIntegEnergy is a helper function for ComputeEnergyChunk;
  // it computes using "RECT_INTEG" method.
  void RectIntegEnergy(const Oxs_SimState& state,
                       Oxs_ComputeEnergyDataThreaded& ocedt,
                       Oxs_ComputeEnergyDataThreadedAux& ocedtaux,
                       OC_INDEX node_start,OC_INDEX node_stop) const;

  // KL(m)
  // MvarIntegEnergy is a helper function for ComputeEnergyChunk;
  // it computes using "LLB_INTEG" method.
  void LLBIntegEnergy(const Oxs_SimState& state,
                       Oxs_ComputeEnergyDataThreaded& ocedt,
                       Oxs_ComputeEnergyDataThreadedAux& ocedtaux,
                       OC_INDEX node_start,OC_INDEX node_stop) const;

protected:
  virtual void GetEnergy(const Oxs_SimState& state,
			 Oxs_EnergyData& oed) const {
    GetEnergyAlt(state,oed);
  }

  virtual void ComputeEnergy(const Oxs_SimState& state,
                             Oxs_ComputeEnergyData& oced) const {
    ComputeEnergyAlt(state,oced);
  }

/* KLque: czy to potrzebne??  
  virtual void ComputeEnergyChunkInitialize
  (const Oxs_SimState& state,
   Oxs_ComputeEnergyDataThreaded& ocedt,
   Oc_AlignedVector<Oxs_ComputeEnergyDataThreadedAux>& thread_ocedtaux,
   int number_of_threads) const;  
  
  a preconditioner??
*/
  
  virtual void ComputeEnergyChunk(const Oxs_SimState& state,
                                  Oxs_ComputeEnergyDataThreaded& ocedt,
                                  Oxs_ComputeEnergyDataThreadedAux& ocedtaux,
                                  OC_INDEX node_start,OC_INDEX node_stop,
                                  int threadnumber) const;
public:
  virtual const char* ClassName() const; // ClassName() is
  /// automatically generated by the OXS_EXT_REGISTER macro.
  Klm_Anisotropy(const char* name,  // Child instance id
			 Oxs_Director* newdtr, // App director
			 const char* argstr);  // MIF input block parameters
  virtual ~Klm_Anisotropy() {}
  virtual OC_BOOL Init();
};


#endif // _KLM_ANISOTROPY
